<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on PzNotes - Learning and Sharing</title>
    <link>https://whu-pzhang.github.io/categories/programming/</link>
    <description>Recent content in Programming on PzNotes - Learning and Sharing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 08 Apr 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://whu-pzhang.github.io/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MPI之环境配置</title>
      <link>https://whu-pzhang.github.io/mpi-intro/</link>
      <pubDate>Sun, 08 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/mpi-intro/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt; 很久之前挖的坑，现在慢慢填坑中……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为 MPI 系列学习笔记的开始，本文介绍如何在服务器上配置 MPI 环境。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; 中的 define 和 typedef</title>
      <link>https://whu-pzhang.github.io/define-and-typedef/</link>
      <pubDate>Fri, 13 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/define-and-typedef/</guid>
      <description>&lt;p&gt;c语言中，&lt;code&gt;#define&lt;/code&gt; 和 &lt;code&gt;typedef&lt;/code&gt; 均是用来定义别名的符号，但又有明显的不同。
&lt;code&gt;#define&lt;/code&gt; 定义的宏只是简单的文本替换，&lt;code&gt;typedef&lt;/code&gt; 则是类型别名。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用ctypes调用C函数</title>
      <link>https://whu-pzhang.github.io/python-ctypes/</link>
      <pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/python-ctypes/</guid>
      <description>&lt;p&gt;现在已有一些C语言函数被编译成共享库，我们想从纯Python中直接调用这些函数，而不必额外编写C代码或者使用第三方的扩展工具。&lt;/p&gt;
&lt;p&gt;对于这样的需求，使用Python标准库中的&lt;code&gt;ctypes&lt;/code&gt;模块来实现是非常容易的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>NumPy学习笔记</title>
      <link>https://whu-pzhang.github.io/learn-numpy/</link>
      <pubDate>Wed, 03 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/learn-numpy/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.numpy.org/&#34;&gt;NumPy&lt;/a&gt; 为 Python下科学计算的基础包。&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;NumPy 的出现主要是弥补 Python 数值计算的不足。为 Python 科学计算提供了强大的支撑。&lt;/p&gt;
&lt;p&gt;NumPy 主要提供了两种对象：ndarray(N-dimensional array)和 ufunc(Unversal function)。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python科学计算环境Anaconda</title>
      <link>https://whu-pzhang.github.io/python-anaconda/</link>
      <pubDate>Tue, 05 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/python-anaconda/</guid>
      <description>&lt;p&gt;本文记录Python科学计算发行版Anaconda的介绍，安装以及后续的一些应用。&lt;/p&gt;
&lt;h2 id=&#34;anaconda-特性&#34;&gt;Anaconda 特性&lt;/h2&gt;
&lt;p&gt;主页： &lt;a href=&#34;https://www.continuum.io/&#34;&gt;https://www.continuum.io/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含了众多流行的科学、教学、工程和数据分析的Python包&lt;/li&gt;
&lt;li&gt;完全开源、免费&lt;/li&gt;
&lt;li&gt;对于学术用途可以申请免费的加速 icense&lt;/li&gt;
&lt;li&gt;全平台支持： Linux、Windows、Mac&lt;/li&gt;
&lt;li&gt;支持Python2.6、2.7、3.4、3.5&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>在C程序中读写SU格式文件</title>
      <link>https://whu-pzhang.github.io/read-and-write-su-in-c/</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/read-and-write-su-in-c/</guid>
      <description>&lt;h2 id=&#34;序言&#34;&gt;序言&lt;/h2&gt;
&lt;p&gt;Seismic_Unix是处理勘探地震数据的好工具，SU文件格式是其内部的默认格式，有时候需要自己在程序
中读写SU文件。本文介绍如何在C程序中读写SU格式文件。&lt;/p&gt;
&lt;h2 id=&#34;子函数库&#34;&gt;子函数库&lt;/h2&gt;
&lt;p&gt;Seismic_Unix程序自带有子函数库，但是我没有找到相关的程序源码。。。。&lt;/p&gt;
&lt;p&gt;但是其中自带的 &lt;code&gt;segy.h&lt;/code&gt; 头文件可以帮助我们了解SU文件的道头格式，而且可以利用该头文件
来对SU格式的文件进行读写。&lt;/p&gt;
&lt;p&gt;关于SU文件格式可以参考&lt;a href=&#34;https://whu-pzhang.github.io/SU-and-Segy-format.html&#34;&gt;SU/SEGY文件格式&lt;/a&gt; 一文。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一些有用的算法收集</title>
      <link>https://whu-pzhang.github.io/useful-algorithms/</link>
      <pubDate>Fri, 16 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/useful-algorithms/</guid>
      <description>&lt;p&gt;收集了一些可能会用到的小算法。&lt;/p&gt;
&lt;h2 id=&#34;判断字节序&#34;&gt;判断字节序&lt;/h2&gt;
&lt;p&gt;在处理数据是常常会碰到字节序(Byte Endian)的问题&lt;/p&gt;
&lt;p&gt;Linux下可以直接用Shell命令查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lscpu | grep -i byte
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>getopt用法</title>
      <link>https://whu-pzhang.github.io/usage-of-getopt/</link>
      <pubDate>Sun, 20 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/usage-of-getopt/</guid>
      <description>&lt;h2 id=&#34;getopt介绍&#34;&gt;getopt介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;getopt&lt;/code&gt; 为Linux下处理命令行参数的函数，相对于自己编写代码来解析命令行参数，
getopt提供了更为方便和友好的方式。&lt;/p&gt;
&lt;p&gt;函数 &lt;code&gt;getopt&lt;/code&gt; 包含于系统头文件 &lt;code&gt;unistd.h&lt;/code&gt; 中，其函数原型为:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getopt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; argv[], &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;optstring);
&lt;span style=&#34;color:#66d9ef&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;optarg;
&lt;span style=&#34;color:#66d9ef&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; optind, opterr, optopt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>C语言中多维数组的动态分配</title>
      <link>https://whu-pzhang.github.io/dynamic-allocate-2d-array/</link>
      <pubDate>Sun, 02 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/dynamic-allocate-2d-array/</guid>
      <description>&lt;p&gt;在C语言中，数组是最常用到的。分为静态数组和动态数组。
静态数据即数组长度预先定义好，一旦给定大小就无法再改变长度，静态数组用完后会自动释放
内存。&lt;/p&gt;
&lt;p&gt;c99 标准中加入了&lt;a href=&#34;http://en.cppreference.com/w/c/language/array&#34;&gt;变长数组VLA&lt;/a&gt;，
数组大小可以用非整数常量表达式表示。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;size_t n1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, n2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;35&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; a[n1], b[n1][n2];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但当需要的数组大小过大时，栈（stack）上空间就会不够用，静态数组会失败，俗称爆栈。
这时就需要动态地从堆（heap）上分配内存，即动态分配。
动态数组的长度则是随程序的需要来指定的。
标准C语言中提供动态分配和释放的函数，包含于头文件 &lt;code&gt;stdlib.h&lt;/code&gt; 中。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数组和指针</title>
      <link>https://whu-pzhang.github.io/array-and-pointer/</link>
      <pubDate>Fri, 31 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://whu-pzhang.github.io/array-and-pointer/</guid>
      <description>&lt;h2 id=&#34;数组名和指针&#34;&gt;数组名和指针&lt;/h2&gt;
&lt;p&gt;在C语言中，数组和指针是紧密联系在一起的，对于数组来说，数组名就是数组第一个元素的地址，
不同的是数组名是一个常量，而指针则是变量。这是两者之间的最主要区别。&lt;/p&gt;
&lt;p&gt;事实上，数组名和指针除了上述区别外，还有其他的一些不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在声明时，只有作为函数参数的数组名编译器会将其转化成指针。其他情况下，数组名和指针是完全不一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在引用上，数组名只需访问内存一次；而指针需要访问内存两次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若a是一个数组名，p为指向该数组的指针变量，使用 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;&amp;amp;a&lt;/code&gt; 得到的值是一样的。对 &lt;code&gt;p&lt;/code&gt; 来说则不一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sizeof a&lt;/code&gt; 得到的是整个数组所占字节的大小，而 &lt;code&gt;sizeof p&lt;/code&gt; 得到的是指针所占字节的大小(32位系统为4个字节，64位系统为8个字节)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽管 &lt;code&gt;a&lt;/code&gt;和 &lt;code&gt;&amp;amp;a[0]&lt;/code&gt; 得到的地址是一样的，但是其意义是不一样的，&lt;code&gt;a&lt;/code&gt;表示的是存储数组这块连续内存空间的首地址而 &lt;code&gt;&amp;amp;a[0]&lt;/code&gt;表示的是数组第一个元素的首地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
  </channel>
</rss>